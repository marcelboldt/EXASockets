.TH "RAPIDJSON_ERRORS" 3 "Thu Nov 3 2016" "Version 0.9" "EXASockets" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RAPIDJSON_ERRORS \- RapidJSON error handling
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBParseResult\fP"
.br
.RI "Result of parsing (wraps ParseErrorCode) "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBRAPIDJSON_ERROR_CHARTYPE\fP   char"
.br
.RI "Character type of error messages\&. "
.ti -1c
.RI "#define \fBRAPIDJSON_ERROR_STRING\fP(x)   x"
.br
.RI "Macro for converting string literial to \fBRAPIDJSON_ERROR_CHARTYPE\fP[]\&. "
.ti -1c
.RI "#define \fBRAPIDJSON_PARSE_ERROR_NORETURN\fP(parseErrorCode,  offset)"
.br
.RI "Macro to indicate a parse error\&. "
.ti -1c
.RI "#define \fBRAPIDJSON_PARSE_ERROR\fP(parseErrorCode,  offset)"
.br
.RI "(Internal) macro to indicate and handle a parse error\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef const \fBRAPIDJSON_ERROR_CHARTYPE\fP *(* \fBGetParseErrorFunc\fP) (\fBParseErrorCode\fP)"
.br
.RI "Function pointer type of GetParseError()\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBParseErrorCode\fP { \fBkParseErrorNone\fP = 0, \fBkParseErrorDocumentEmpty\fP, \fBkParseErrorDocumentRootNotSingular\fP, \fBkParseErrorValueInvalid\fP, \fBkParseErrorObjectMissName\fP, \fBkParseErrorObjectMissColon\fP, \fBkParseErrorObjectMissCommaOrCurlyBracket\fP, \fBkParseErrorArrayMissCommaOrSquareBracket\fP, \fBkParseErrorStringUnicodeEscapeInvalidHex\fP, \fBkParseErrorStringUnicodeSurrogateInvalid\fP, \fBkParseErrorStringEscapeInvalid\fP, \fBkParseErrorStringMissQuotationMark\fP, \fBkParseErrorStringInvalidEncoding\fP, \fBkParseErrorNumberTooBig\fP, \fBkParseErrorNumberMissFraction\fP, \fBkParseErrorNumberMissExponent\fP, \fBkParseErrorTermination\fP, \fBkParseErrorUnspecificSyntaxError\fP }
.RI "Error code of parsing\&. ""
.br
.ti -1c
.RI "enum \fBPointerParseErrorCode\fP { \fBkPointerParseErrorNone\fP = 0, \fBkPointerParseErrorTokenMustBeginWithSolidus\fP, \fBkPointerParseErrorInvalidEscape\fP, \fBkPointerParseErrorInvalidPercentEncoding\fP, \fBkPointerParseErrorCharacterMustPercentEncode\fP }
.RI "Error code of parsing\&. ""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBRAPIDJSON_NAMESPACE_BEGIN\fP const \fBRAPIDJSON_ERROR_CHARTYPE\fP * \fBGetParseError_En\fP (\fBParseErrorCode\fP parseErrorCode)"
.br
.RI "Maps error code of parsing into error message\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SH "Macro Definition Documentation"
.PP 
.SS "#define RAPIDJSON_ERROR_CHARTYPE   char"

.PP
Character type of error messages\&. The default character type is \fCchar\fP\&. On Windows, user can define this macro as \fCTCHAR\fP for supporting both unicode/non-unicode settings\&. 
.SS "#define RAPIDJSON_ERROR_STRING(x)   x"

.PP
Macro for converting string literial to \fBRAPIDJSON_ERROR_CHARTYPE\fP[]\&. By default this conversion macro does nothing\&. On Windows, user can define this macro as \fC_T(x)\fP for supporting both unicode/non-unicode settings\&. 
.SS "#define RAPIDJSON_PARSE_ERROR(parseErrorCode, offset)"

.PP
(Internal) macro to indicate and handle a parse error\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparseErrorCode\fP \fBrapidjson::ParseErrorCode\fP of the error 
.br
\fIoffset\fP position of the error in JSON input (\fCsize_t\fP)
.RE
.PP
Invokes RAPIDJSON_PARSE_ERROR_NORETURN and stops the parsing\&.
.PP
\fBSee also:\fP
.RS 4
\fBRAPIDJSON_PARSE_ERROR_NORETURN\fP 
.RE
.PP

.SS "#define RAPIDJSON_PARSE_ERROR_NORETURN(parseErrorCode, offset)"
\fBValue:\fP
.PP
.nf
RAPIDJSON_MULTILINEMACRO_BEGIN \\
    RAPIDJSON_ASSERT(!HasParseError()); /* Error can only be assigned once */ \
    SetParseError(parseErrorCode, offset); \
    RAPIDJSON_MULTILINEMACRO_END
.fi
.PP
Macro to indicate a parse error\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparseErrorCode\fP \fBrapidjson::ParseErrorCode\fP of the error 
.br
\fIoffset\fP position of the error in JSON input (\fCsize_t\fP)
.RE
.PP
This macros can be used as a customization point for the internal error handling mechanism of RapidJSON\&.
.PP
A common usage model is to throw an exception instead of requiring the caller to explicitly check the \fBrapidjson::GenericReader::Parse\fP's return value:
.PP
.PP
.nf
#define RAPIDJSON_PARSE_ERROR_NORETURN(parseErrorCode,offset) \
   throw ParseException(parseErrorCode, #parseErrorCode, offset)

#include <stdexcept>               // std::runtime_error
#include "rapidjson/error/error\&.h" // rapidjson::ParseResult

struct ParseException : std::runtime_error, rapidjson::ParseResult {
  ParseException(rapidjson::ParseErrorCode code, const char* msg, size_t offset)
    : std::runtime_error(msg), ParseResult(code, offset) {}
};

#include "rapidjson/reader\&.h"
.fi
.PP
.PP
\fBSee also:\fP
.RS 4
\fBRAPIDJSON_PARSE_ERROR\fP, rapidjson::GenericReader::Parse 
.RE
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef const \fBRAPIDJSON_ERROR_CHARTYPE\fP*(* GetParseErrorFunc) (\fBParseErrorCode\fP)"

.PP
Function pointer type of GetParseError()\&. This is the prototype for \fCGetParseError_X()\fP, where \fCX\fP is a locale\&. User can dynamically change locale in runtime, e\&.g\&.: 
.PP
.nf
GetParseErrorFunc GetParseError = GetParseError_En; // or whatever
const RAPIDJSON_ERROR_CHARTYPE* s = GetParseError(document\&.GetParseErrorCode());

.fi
.PP
 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBParseErrorCode\fP"

.PP
Error code of parsing\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGenericReader::Parse\fP, \fBGenericReader::GetParseErrorCode\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIkParseErrorNone \fP\fP
No error\&. 
.TP
\fB\fIkParseErrorDocumentEmpty \fP\fP
The document is empty\&. 
.TP
\fB\fIkParseErrorDocumentRootNotSingular \fP\fP
The document root must not follow by other values\&. 
.TP
\fB\fIkParseErrorValueInvalid \fP\fP
Invalid value\&. 
.TP
\fB\fIkParseErrorObjectMissName \fP\fP
Missing a name for object member\&. 
.TP
\fB\fIkParseErrorObjectMissColon \fP\fP
Missing a colon after a name of object member\&. 
.TP
\fB\fIkParseErrorObjectMissCommaOrCurlyBracket \fP\fP
Missing a comma or '}' after an object member\&. 
.TP
\fB\fIkParseErrorArrayMissCommaOrSquareBracket \fP\fP
Missing a comma or ']' after an array element\&. 
.TP
\fB\fIkParseErrorStringUnicodeEscapeInvalidHex \fP\fP
Incorrect hex digit after \\u escape in string\&. 
.TP
\fB\fIkParseErrorStringUnicodeSurrogateInvalid \fP\fP
The surrogate pair in string is invalid\&. 
.TP
\fB\fIkParseErrorStringEscapeInvalid \fP\fP
Invalid escape character in string\&. 
.TP
\fB\fIkParseErrorStringMissQuotationMark \fP\fP
Missing a closing quotation mark in string\&. 
.TP
\fB\fIkParseErrorStringInvalidEncoding \fP\fP
Invalid encoding in string\&. 
.TP
\fB\fIkParseErrorNumberTooBig \fP\fP
Number too big to be stored in double\&. 
.TP
\fB\fIkParseErrorNumberMissFraction \fP\fP
Miss fraction part in number\&. 
.TP
\fB\fIkParseErrorNumberMissExponent \fP\fP
Miss exponent in number\&. 
.TP
\fB\fIkParseErrorTermination \fP\fP
Parsing was terminated\&. 
.TP
\fB\fIkParseErrorUnspecificSyntaxError \fP\fP
Unspecific syntax error\&. 
.SS "enum \fBPointerParseErrorCode\fP"

.PP
Error code of parsing\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGenericPointer::GenericPointer\fP, GenericPointer::GetParseErrorCode 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIkPointerParseErrorNone \fP\fP
The parse is successful\&. 
.TP
\fB\fIkPointerParseErrorTokenMustBeginWithSolidus \fP\fP
A token must begin with a '/'\&. 
.TP
\fB\fIkPointerParseErrorInvalidEscape \fP\fP
Invalid escape\&. 
.TP
\fB\fIkPointerParseErrorInvalidPercentEncoding \fP\fP
Invalid percent encoding in URI fragment\&. 
.TP
\fB\fIkPointerParseErrorCharacterMustPercentEncode \fP\fP
A character must percent encoded in URI fragment\&. 
.SH "Function Documentation"
.PP 
.SS "\fBRAPIDJSON_NAMESPACE_BEGIN\fP const \fBRAPIDJSON_ERROR_CHARTYPE\fP* GetParseError_En (\fBParseErrorCode\fP parseErrorCode)\fC [inline]\fP"

.PP
Maps error code of parsing into error message\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparseErrorCode\fP Error code obtained in parsing\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the error message\&. 
.RE
.PP
\fBNote:\fP
.RS 4
User can make a copy of this function for localization\&. Using switch-case is safer for future modification of error codes\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for EXASockets from the source code\&.
