.TH "Writer< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >" 3 "Thu Nov 3 2016" "Version 0.9" "EXASockets" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Writer< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags > \- JSON writer\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <writer\&.h>\fP
.PP
Inherited by \fBPrettyWriter< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBLevel\fP"
.br
.RI "Information for each nested level\&. "
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef SourceEncoding::Ch \fBCh\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBWriter\fP (OutputStream &os, StackAllocator *stackAllocator=0, size_t levelDepth=kDefaultLevelDepth)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "\fBWriter\fP (StackAllocator *allocator=0, size_t levelDepth=kDefaultLevelDepth)"
.br
.ti -1c
.RI "void \fBReset\fP (OutputStream &os)"
.br
.RI "Reset the writer with a new stream\&. "
.ti -1c
.RI "bool \fBIsComplete\fP () const"
.br
.RI "Checks whether the output is a complete JSON\&. "
.ti -1c
.RI "int \fBGetMaxDecimalPlaces\fP () const"
.br
.ti -1c
.RI "void \fBSetMaxDecimalPlaces\fP (int maxDecimalPlaces)"
.br
.RI "Sets the maximum number of decimal places for double output\&. "
.ti -1c
.RI "bool \fBRawValue\fP (const Ch *json, size_t length, \fBType\fP type)"
.br
.RI "Write a raw JSON value\&. "
.in -1c
.PP
.RI "\fBImplementation of Handler\fP"
.br

.PP
\fBSee also:\fP
.RS 4
Handler 
.RE
.PP

.PP
.in +1c
.in +1c
.ti -1c
.RI "bool \fBNull\fP ()"
.br
.ti -1c
.RI "bool \fBBool\fP (bool b)"
.br
.ti -1c
.RI "bool \fBInt\fP (int i)"
.br
.ti -1c
.RI "bool \fBUint\fP (unsigned u)"
.br
.ti -1c
.RI "bool \fBInt64\fP (int64_t i64)"
.br
.ti -1c
.RI "bool \fBUint64\fP (uint64_t u64)"
.br
.ti -1c
.RI "bool \fBDouble\fP (double d)"
.br
.RI "Writes the given \fCdouble\fP value to the stream\&. "
.ti -1c
.RI "bool \fBRawNumber\fP (const Ch *str, \fBSizeType\fP length, bool copy=false)"
.br
.ti -1c
.RI "bool \fBString\fP (const Ch *str, \fBSizeType\fP length, bool copy=false)"
.br
.ti -1c
.RI "bool \fBStartObject\fP ()"
.br
.ti -1c
.RI "bool \fBKey\fP (const Ch *str, \fBSizeType\fP length, bool copy=false)"
.br
.ti -1c
.RI "bool \fBEndObject\fP (\fBSizeType\fP memberCount=0)"
.br
.ti -1c
.RI "bool \fBStartArray\fP ()"
.br
.ti -1c
.RI "bool \fBEndArray\fP (\fBSizeType\fP elementCount=0)"
.br
.in -1c
.in -1c
.PP
.RI "\fBConvenience extensions\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "bool \fBString\fP (const Ch *str)"
.br
.RI "Simpler but slower overload\&. "
.ti -1c
.RI "bool \fBKey\fP (const Ch *str)"
.br
.in -1c
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBkDefaultMaxDecimalPlaces\fP = 324"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "bool \fBWriteNull\fP ()"
.br
.ti -1c
.RI "bool \fBWriteBool\fP (bool b)"
.br
.ti -1c
.RI "bool \fBWriteInt\fP (int i)"
.br
.ti -1c
.RI "bool \fBWriteUint\fP (unsigned u)"
.br
.ti -1c
.RI "bool \fBWriteInt64\fP (int64_t i64)"
.br
.ti -1c
.RI "bool \fBWriteUint64\fP (uint64_t u64)"
.br
.ti -1c
.RI "bool \fBWriteDouble\fP (double d)"
.br
.ti -1c
.RI "bool \fBWriteString\fP (const Ch *str, \fBSizeType\fP length)"
.br
.ti -1c
.RI "bool \fBScanWriteUnescapedString\fP (\fBGenericStringStream\fP< SourceEncoding > &is, size_t length)"
.br
.ti -1c
.RI "bool \fBWriteStartObject\fP ()"
.br
.ti -1c
.RI "bool \fBWriteEndObject\fP ()"
.br
.ti -1c
.RI "bool \fBWriteStartArray\fP ()"
.br
.ti -1c
.RI "bool \fBWriteEndArray\fP ()"
.br
.ti -1c
.RI "bool \fBWriteRawValue\fP (const Ch *json, size_t length)"
.br
.ti -1c
.RI "void \fBPrefix\fP (\fBType\fP type)"
.br
.ti -1c
.RI "bool \fBEndValue\fP (bool ret)"
.br
.ti -1c
.RI "template<> bool \fBWriteInt\fP (int i)"
.br
.ti -1c
.RI "template<> bool \fBWriteUint\fP (unsigned u)"
.br
.ti -1c
.RI "template<> bool \fBWriteInt64\fP (int64_t i64)"
.br
.ti -1c
.RI "template<> bool \fBWriteUint64\fP (uint64_t u)"
.br
.ti -1c
.RI "template<> bool \fBWriteDouble\fP (double d)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "OutputStream * \fBos_\fP"
.br
.ti -1c
.RI "\fBinternal::Stack\fP< StackAllocator > \fBlevel_stack_\fP"
.br
.ti -1c
.RI "int \fBmaxDecimalPlaces_\fP"
.br
.ti -1c
.RI "bool \fBhasRoot_\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static const size_t \fBkDefaultLevelDepth\fP = 32"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename OutputStream, typename SourceEncoding = UTF8<>, typename TargetEncoding = UTF8<>, typename StackAllocator = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags>
.br
class Writer< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >"
JSON writer\&. 

\fBWriter\fP implements the concept Handler\&. It generates JSON text by events to an output os\&.
.PP
User may programmatically calls the functions of a writer to generate JSON text\&.
.PP
On the other side, a writer can also be passed to objects that generates events,
.PP
for example \fBReader::Parse()\fP and Document::Accept()\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIOutputStream\fP Type of output stream\&. 
.br
\fISourceEncoding\fP Encoding of source string\&. 
.br
\fITargetEncoding\fP Encoding of output stream\&. 
.br
\fIStackAllocator\fP Type of allocator for allocating memory of stack\&. 
.RE
.PP
\fBNote:\fP
.RS 4
implements Handler concept 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename OutputStream , typename SourceEncoding  = UTF8<>, typename TargetEncoding  = UTF8<>, typename StackAllocator  = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags> \fBWriter\fP< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >::\fBWriter\fP (OutputStream & os, StackAllocator * stackAllocator = \fC0\fP, size_t levelDepth = \fCkDefaultLevelDepth\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIos\fP Output stream\&. 
.br
\fIstackAllocator\fP User supplied allocator\&. If it is null, it will create a private one\&. 
.br
\fIlevelDepth\fP Initial capacity of stack\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename OutputStream , typename SourceEncoding  = UTF8<>, typename TargetEncoding  = UTF8<>, typename StackAllocator  = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags> bool \fBWriter\fP< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >::Double (double d)\fC [inline]\fP"

.PP
Writes the given \fCdouble\fP value to the stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fId\fP The value to be written\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether it is succeed\&. 
.RE
.PP

.SS "template<typename OutputStream , typename SourceEncoding  = UTF8<>, typename TargetEncoding  = UTF8<>, typename StackAllocator  = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags> bool \fBWriter\fP< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >::IsComplete () const\fC [inline]\fP"

.PP
Checks whether the output is a complete JSON\&. A complete JSON has a complete root object or array\&. 
.SS "template<typename OutputStream , typename SourceEncoding  = UTF8<>, typename TargetEncoding  = UTF8<>, typename StackAllocator  = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags> bool \fBWriter\fP< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >::RawValue (const Ch * json, size_t length, \fBType\fP type)\fC [inline]\fP"

.PP
Write a raw JSON value\&. For user to write a stringified JSON as a value\&.
.PP
\fBParameters:\fP
.RS 4
\fIjson\fP A well-formed JSON value\&. It should not contain null character within [0, length - 1] range\&. 
.br
\fIlength\fP Length of the json\&. 
.br
\fItype\fP Type of the root of json\&. 
.RE
.PP

.SS "template<typename OutputStream , typename SourceEncoding  = UTF8<>, typename TargetEncoding  = UTF8<>, typename StackAllocator  = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags> void \fBWriter\fP< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >::Reset (OutputStream & os)\fC [inline]\fP"

.PP
Reset the writer with a new stream\&. This function reset the writer with a new stream and default settings, in order to make a \fBWriter\fP object reusable for output multiple JSONs\&.
.PP
\fBParameters:\fP
.RS 4
\fIos\fP New output stream\&. 
.PP
.nf
Writer<OutputStream> writer(os1);
writer\&.StartObject();
// \&.\&.\&.
writer\&.EndObject();

writer\&.Reset(os2);
writer\&.StartObject();
// \&.\&.\&.
writer\&.EndObject();

.fi
.PP
 
.RE
.PP

.SS "template<typename OutputStream, typename SourceEncoding = UTF8<>, typename TargetEncoding = UTF8<>, typename StackAllocator = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags> void \fBWriter\fP< OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags >::SetMaxDecimalPlaces (int maxDecimalPlaces)\fC [inline]\fP"

.PP
Sets the maximum number of decimal places for double output\&. This setting truncates the output with specified number of decimal places\&.
.PP
For example,
.PP
.PP
.nf
writer\&.SetMaxDecimalPlaces(3);
writer\&.StartArray();
writer\&.Double(0\&.12345);                 // "0\&.123"
writer\&.Double(0\&.0001);                  // "0\&.0"
writer\&.Double(1\&.234567890123456e30);    // "1\&.234567890123456e30" (do not truncate significand for positive exponent)
writer\&.Double(1\&.23e-4);                 // "0\&.0"                  (do truncate significand for negative exponent)
writer\&.EndArray();
.fi
.PP
.PP
The default setting does not truncate any decimal places\&. You can restore to this setting by calling 
.PP
.nf
writer\&.SetMaxDecimalPlaces(Writer::kDefaultMaxDecimalPlaces);

.fi
.PP
 

.SH "Author"
.PP 
Generated automatically by Doxygen for EXASockets from the source code\&.
